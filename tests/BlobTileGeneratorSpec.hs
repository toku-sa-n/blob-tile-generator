{-# LANGUAGE TupleSections #-}

module BlobTileGeneratorSpec
    ( spec
    ) where

import           BlobTileGenerator       (TileType (CornerInside, CornerOutside, Horizontal, NoBorder, Vertical),
                                          fromPartsUnchecked,
                                          fromTypesUnchecked, generateBlobTile,
                                          indexToTile, indexToTileTypes,
                                          isCorrectSize, splitImage)
import           Codec.Picture           (Image, PixelRGB8 (PixelRGB8),
                                          convertRGBA8, generateImage,
                                          readImage)
import           Codec.Picture.Extra     (below)
import           Data.Either.Combinators (fromRight')
import           Data.Maybe              (isNothing)
import           Test.Hspec              (Spec, describe, it, runIO, shouldBe)

spec :: Spec
spec = do
    testIsCorrectSize
    testSplitImage
    testIndexToTileTypes
    testIndexToTile
    testGenerateBlobTile

testGenerateBlobTile :: Spec
testGenerateBlobTile = do
    input <- readImage' "tests/input.png"
    expected <- readImage' "tests/expected.png"
    describe "generateBlobTile" $
        it
            "returns a Just value containing a blob tile generated by the passed 1x5 tile image" $
        generateBlobTile input == Just expected
  where
    readImage' = runIO . fmap (convertRGBA8 . fromRight') . readImage

testSplitImage :: Spec
testSplitImage =
    describe "tile1x5" $ do
        it
            "returns a Just value including the Tile1x5 type value containing images separated into 5. if the image has a correct size." $
            splitImage correctTileFile == Just expected
        it "returns a Nothing if the given tile has an incorrect size." $
            and $ fmap (isNothing . splitImage) incorrectSizeImages
  where
    correctTileFile = below [t1, t2, t3, t4, t5]
    expected = fromPartsUnchecked t1 t2 t3 t4 t5
    (t1, t2, t3, t4, t5) =
        case fmap blueToTile [0 .. 4] of
            [a, b, c, d, e] -> (a, b, c, d, e)
            _               -> error "Unexpected list length"
    blueToTile b = generateImage (\_ _ -> PixelRGB8 0 0 b) 2 2

testIsCorrectSize :: Spec
testIsCorrectSize =
    describe "isCorrectSize" $
    it "returns True if the given has a width-to-height ratio of 1:5, and an even width." $
    mapM_ checkFunc patterns
  where
    patterns = [(correctSize, True)] <> fmap (, False) incorrectSizeImages
    checkFunc (img, expected) = isCorrectSize img `shouldBe` expected
    correctSize = generateBlackImage 2 10

testIndexToTileTypes :: Spec
testIndexToTileTypes =
    describe "indexToTileTypes" $ do
        it "returns a Just value containing tile types of each corner" $ do
            success 85 CornerInside CornerInside CornerInside CornerInside
            success 255 NoBorder NoBorder NoBorder NoBorder
            success 17 Vertical Vertical Vertical Vertical
            success 5 Vertical CornerInside CornerOutside Horizontal
            success 68 Horizontal Horizontal Horizontal Horizontal
            success 29 Vertical CornerInside Vertical NoBorder
            success 112 Horizontal CornerOutside NoBorder Vertical
        it "returns a Nothing value if the index is invalid." $
            indexToTileTypes 334 `shouldBe` Nothing
  where
    success index nw ne sw se =
        indexToTileTypes index `shouldBe` Just (fromTypesUnchecked nw ne sw se)

testIndexToTile :: Spec
testIndexToTile =
    describe "indexToTile" $ do
        it
            "returns a Just value containing a tile image generated by a Tile1x5 value" $
            evalFunc 85 (3, 3, 3, 3) &&
            evalFunc 255 (4, 4, 4, 4) &&
            evalFunc 17 (1, 1, 1, 1) && evalFunc 5 (1, 3, 0, 2)
        it "returns a Nothing value if the given index is invalid." $
            isNothing $ indexToTile tile1x5Image 334
  where
    evalFunc index colors =
        indexToTile tile1x5Image index == Just (tileFromBlue colors)
    tileFromBlue colors =
        generateImage (\x -> PixelRGB8 0 0 . specifyColor colors x) 2 2
    specifyColor (nw, _, _, _) 0 0 = nw
    specifyColor (_, ne, _, _) 1 0 = ne
    specifyColor (_, _, sw, _) 0 1 = sw
    specifyColor (_, _, _, se) 1 1 = se
    specifyColor _ _ _             = error "Out of index."
    tile1x5Image = fromPartsUnchecked t1 t2 t3 t4 t5
    (t1, t2, t3, t4, t5) =
        case fmap blueToTile [0 .. 4] of
            [a, b, c, d, e] -> (a, b, c, d, e)
            _               -> error "Unexpected list length"
    blueToTile b = generateImage (\_ _ -> PixelRGB8 0 0 b) 2 2

incorrectSizeImages :: [Image PixelRGB8]
incorrectSizeImages = [oddWidth, incorrectRatio]
  where
    oddWidth = generateBlackImage 1 5
    incorrectRatio = generateBlackImage 2 9

generateBlackImage :: Int -> Int -> Image PixelRGB8
generateBlackImage = generateImage (\_ _ -> PixelRGB8 0 0 0)
